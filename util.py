"""
This module contains functions that are not quite related to the assembly
itself.
"""
from collections import Counter
import subprocess

import pysam


def parse_art_orientation(aln_fnames):
    """
    Receives paths to *.aln files generated by art_illumina.
    Returns dictionary that maps ids of reads to their orientation which is
    either '+' or '-'. '-' means that the read is reverse complement of
    original sequence.
    """
    orientation = {}
    for aln_fname in aln_fnames:
        with open(aln_fname, 'r', encoding='utf-8') as f:
            for line in f.readlines():
                if line[0] != '>':
                    continue
                read_info = line[:-1].split('\t')
                # ART adds a redundant '-1' at the end of ids in the first .aln
                # file, so we remove it
                read_id = '-'.join(read_info[1].split('-')[0:2])
                orientation[read_id] = read_info[-1]
    return orientation


def compute_identity(aligner, seq1, seq2):
    """
    Receives Bio.Align.PairwiseAligner and two sequences.
    Returns the identity of these sequences â€” measure of their similarity.
    """
    s1, s2 = next(aligner.align(seq1, seq2))
    alignment_len = len(s1)
    match_count = 0
    for i in range(alignment_len):
        if s1[i] == s2[i]:
            match_count += 1
    return match_count / alignment_len


def align(sam_fname, ref_fname, query_fnames):
    """
    Name of sorted SAM file to create, name of FASTA/FASTQ file
    containing reference sequence and names of FASTA/FASTQ files
    containing query sequence which to map onto the
    given sequence using minimap2 aligner.
    """
    with open(sam_fname, 'w', encoding='utf-8') as sam_file:
        subprocess.run(['minimap2', '-a', ref_fname, *query_fnames],
                       stdout=sam_file,
                       stderr=subprocess.DEVNULL,
                       check=True)
    pysam.sort('-o', sam_fname, sam_fname)


def consensus(sam_fname):
    """
    Receives name of SAM file containing assembled sequence and reads
    mapped to it.
    Returns their consensus sequence.
    """
    with pysam.AlignmentFile(sam_fname, 'rb') as sam:
        consensus_seq = ['N'] * sam.get_reference_length(sam.references[0])
        nucleotide_counter = Counter()
        for pileup_column in sam.pileup():
            nucleotide_counter.clear()
            pos = pileup_column.reference_pos

            for pileup_read in pileup_column.pileups:
                try:
                    nucleotide = pileup_read.alignment.query_sequence[
                            pileup_read.query_position]
                    nucleotide_counter[nucleotide] += 1
                except TypeError:
                    pass  # skip if pileup_read.query_position is None

            consensus_seq[pos] = max(nucleotide_counter,
                                     key=nucleotide_counter.get)

    return ''.join(consensus_seq)
